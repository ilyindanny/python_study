#  int() — преобразование к целому числу в десятичной системе счисления
#  bin() — ... в двоичной
#  hex() — ...в шестнадцатеричной...


# преобразование в список с конвертацией в числовые форматы int или float:

text = '1 2 3 44 5'

lst = [int(x) for x in text.split()]

# функции возвращают минимальное и максимальное число в списке типа int:

min(lst)
max(lst)


# хитинги нужно добавлять. тогда IDE сможет давать подсказки. вот так:

def f1(a: int, b: str) -> int:
    return a + int(b)


# map и comprehensions
str_nums = '1 2 3 4 5 6 7 8'

nums = map(int, str_nums.split())  # это итерируемый объект типа map
 

# а это comprehensions, возвращающий кортежи в список. но так как comprehensions завернут в tuple, то tuple возвращает кортеж кортежей:
s = tuple([(i, i ** 2) for i in nums if i % 2 == 0])  # перед for должно быть написано только то, что непосредственно возвращается  

print(type(s))
print(s)


# это список:
nums = []
# это заполненный список. в квадратных скобках элементы через запятую:
nums = [1, 2, 3, 4, 5, 6, 7, 8]
# и comprehensions, видимо, то же список, потому что точно так же указывается в тех же квадратных скобках:
nums = [x for x in range(8)]
print(nums)


# функция filter(), которой передается в качестве аргумента lambda:

res = list(filter(lambda x: x % 2 == 0, nums))

# фильтр - это итерируемый объект. в скобки передается функция без скобок (то есть не вызывается) и данные.
# объект фильтра — это итерируемый объект. он сохраняет те элементы, для которых функция вернула True.
print(res)

# вот то же самое с отдельным методом вместо лямбды:

def f2(i):
    if i % 2 == 0:
        return True
    else:
        return False


nums = list(filter(f2, nums))
print(nums)

# зарезервированное слово global объявляет переменную с глобальной вилимостью
# зарезервированное слово nonlocal объявляет переменную в вложенном методе с видимостью для основного метода

# обращение по именам при вызове метода:

def func(a, b=5, c=10):
    print('a', a, 'b', b, 'c', c)
func(4, c = 11)



# переменное число параметров
# как только присвоено все основное, остальное будет присваиваиваться параметру со звездочкой (кортеж, потому что нужна именно константа) или двумя звездочками (словарь))

def total(a, *numbers, **phonebook):
    print('a', a)
    
    #проход по всем элементам кортежа
    for single_item in numbers:
        print('single_item', single_item)
    
    #проход по всем элементам словаря
    for first_part, second_part in phonebook.items():
        print(first_part,second_part)

total(10,1,2,Jack=1123,John=2231)



# в методе после переменного числа параметров можно указать еще один параметр, но он обязательно будет параметром по ключу, иначе его не отделить от предыдущих значений. У такого параметра может быти указано значение по умолчанию, например extra_number=6, но передавать аргументы в такой параметр все равно можно только по ключу:


def total(initial=5, *numbers, extra_number=6):
    count = initial
    for number in numbers:
        count += number
    count += extra_number
    print(count)
    
total(10, 1, 2, 3, extra_number=50)

# total(10, 1, 2, 3)  # А это вызовет ошибку, поскольку не указано значение аргумента по умолчанию для 'extra_number'.


# Строки документации. Первая логическая строка функции — строка документации.
# В первой строчке основное название функции или основное действие, что она возвращает.
# Потом пустая строка.
# Потом в третьей строке подробное описание.
# Доступ к строке документации функции printMax можно получить 
# с помощью атрибута этой функции (т.е. имени, принадлежащего ей) точки и __doc__ 
# либо при помощи функции help(printMax) 
# также функция help() попросту выводит те самые строки документации

def printMax(x: int) -> None:
    '''Звголовок. Что выводит функция.
    
    Это третья строка, в ней помещают описание функции.'''
    
    pass

print(printMax.__doc__)
help(printMax)



# Чтобы импортировать функцию randint() прямо в программу 
# и не писать всякий раз random. при обращении к ней, можно воспользоваться выражением «from random import randint». 
# Для импорта всех имён, использующихся в модуле random, 
# можно выполнить команду «from random import *». 
# Это работает для любых модулей.
# Но это ведет к риску пересечения имен,
# поэтому лучше все-таки писать import random, то есть вызывать функцию через имя_модуля.имя_функции

from random import randint
a = randint(2,5)


# удаление переменной:
a = 5
del a













