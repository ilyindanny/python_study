import random

# Списки это вроде массива. Типы могут быть разные. объявляется так:

text_list = []

# Или сразу с инициализацией:
text_list = ['abc', '123', 456]

# Или при помощи функции range:

text_list = list(range(-2, 2))

# Или так:

text_list = [0] * 10

# Копировать:

numbers2 = list(text_list)

# Или так:

numbers2 = text_list[:]

# Срез списка возвращает список:

text_list_cut = text_list[0: 2]
print(text_list_cut)

# А это срез с шагом:

text_list_cut2 = text_list_cut[::2]

# Это проход по списку задом наперед:

text_list_cut[::-1]

# Добавление элемента в конец списка:

text_list.append('789')
print(text_list)

# Добавление элемента в указанную позицию:

text_list.insert(2, 'abc')

# Возвращает последний элемент, удаляя его из массива:

text_pop = text_list.pop()

# Возвращает указанный элемент по индексу, удаляя его из массива:

text_pop = text_list.pop(0)

# Метод очищает весь список:

# text_list.clear()

# Удаление элемента из списка по содержимому:

text_list.remove('abc')
print(text_list)

# Удаление элемента по индексу:

del text_list[1]
print(text_list)

#  Удалить можно даже рандомно:

lst = [1, 2, 3, 4, 5, 6]
lst.pop(random.randint(1, len(lst) - 1))

# Функция возвращает длину списка:
print(len(text_list))

# Двумерный массив и вывод на печать:

a = [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]]

for i in a:
    for j in i:
        print(j, end=' ')
    print()

coll = [3, 9, 4, 5, 2]
9 in coll  # ищет 9 в coll.
print(coll)

# Можно это написать сразу в параметрах функции print:

print(9 in coll)  # вернет True.

# сСортировка списка:

coll.sort()

# Печать списка (только для str):

mylist = ['a', 'b', 'c', 'b']

delimiter = '_*_'
print(delimiter.join(mylist))

# Кортежи.
# Функция кортежа tuple().

a = (1, 2)  # Это кортеж. В отличие от списка инициализируется с круглыми скобками.

a = tuple(['red', 'green', 'blue'])  # Задание кортежа из списка. В квадратных скобках тут как раз список.

t = tuple('a b c d'.split())  # Создание кортежа из строки.

# Чтобы присвоить только одну координату кортежу можно, поставив запятую:
t = (1,)

print(a)  # Обращение ко всему кортежу

print(a[1])  # Обращение к отдельной координате кортежа.

print(a[-2])  # По аналогии с обращением к элементу списка с конца.

# Координате кортежа нельзя присвоить новое значение. a[0] = 3 - ошибка.

colors = ['red', 'green', 'blue']  # это список (тут нужен для примеров).

t = tuple(colors)  # Это кортеж. Инициализируется в круглых скобках.

# tuple() это функция, возвращающая кортеж.

a = tuple(t)  # По аналогии с созданием кортежа из списка тут пример создания списка из кортежа.

for e in t:
    print(e)  # Распечатать все элементы кортежа.

# Создание кортежа из списка и распаковка в переменные:

t = tuple(['red', 'green', 'blue'])
red, green, blue = t  # Это распаковка кортежа в переменные.

a, b, c = 'a b c'.split()  # По аналогии с распаковкой кортежа тут распаковка строки в переменные.

# Еще одно хранилище данных — словари.
# Неупорядоченные коллекции произвольных объектов с доступом по ключу.
# Инициализируется словарь фигурными скобками {}, а обращение по ключу в квадратных []

dictionary = {}  # Объявление словаря.

# Функция словаря dict()

# Обратный слэш позволяет переносить строки. Иначе надо в одну строку писать:

dictionary = \
    {
        '1': 'one',
        '2': 'two',
        '3': 'three'
    }

# Вот та же операция в одну строку:

dictionary = {'1': 'one', '2': 'two'}

print(dictionary)  # Распечатать словарь.

print(dictionary['1'])  # Распечатать значение по ключу.

# В цикле for переменная возвращает ключи.

for k in dictionary.keys():
    print(k)  # распечатать ключи.
for v in dictionary.values():
    print(v)  # распечатать значения.
for i in dictionary:
    print(i)  # это ключи.
for i in dictionary:
    print(dictionary[i])  # это значения по ключу.
for i in dictionary:
    print(dictionary[i], '- ', i)  # это значения по ключу и ключи.

# Особый способ для вывода именно словаря. Списки так не распечатаешь:

for x, y in dictionary.items():
    print(x, y)  # Причем если словарь включен в кортеж как один из его элементов, то этот код тоже работает,
# только писать нужно for x, y in tuple[index].items(): то есть указывать индекс, под которым лежит словарь.

dictionary['1'] = 'first'  # так задается новое значение с ключом '1'.

del dictionary['1']  # удаление значения.


# словарь надстрочных цифр:

diction = \
    {
        1: '\u00B9',
        2: '\u00B2',
        3: '\u00B3',
        4: '\u2074',
        5: '\u2075',
        6: '\u2076',
        7: '\u2077',
        8: '\u2078',
        9: '\u2079'
    }

print('x\u2074')

# и еще вот:

deg_sym = [8304, 185, 178, 179, 8308, 8309, 8310, 8311, 8312, 8313]

for i in deg_sym:
    print('{}{}'.format(3, chr(i)))

# Сортировка словаря:

sd = sorted(diction.keys(), reverse=True)

# Множества.
# Хранение данных. Задается с фигурными скобками {}. Обращение как в списках - элемент берется в скобки ().
# Множества имеют операции логики (пересечение, объединение, разность, симметрическая разность и тд).
# Ключевое слово множества set().


colors = {'abc', 'def', 'ghi'}  # Задать множество.

a = set('a b c d a b'.split())  # Множество из строки (дубликаты удаляются).

colors.add('jkl')  # Добавление элемента.

m = {'a', 'b', 'a'}  # Добавление повторяющегося элемента невозможно, но ошибку не вызывает.

colors.remove('jkl')  # Удаление. Если элемента нет, будет ошибка.


colors.discard('jk')  # Такое удаление не вызывает ошибку, если элемента нет.

colors.clear()  # Очистить.

b = colors.copy()  # Копирование множества colors в новое множество b.

c = colors.union(b)  # Объединение в двух множеств в новой переменной.

d = colors.intersection(b)  # Пересечение.

d = colors.difference(b)  # Множество элементов colors не принадлежащие b.

colors.clear()  # Очистить. Также можно очистить словарь или список. Только кортеж нельзя.

c = frozenset(b)  # Замороженное неизменяемое множество.
