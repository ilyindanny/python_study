# работа с файлами

colors = ['red ', 'green ', 'blue'] # это просто список для примеров

data = open('file.txt', 'w') # 'a' это  дозапись, 'w' перезапись заново, а 'r' - это чтение
data.writelines(colors) # разделителей не будет
data.write('\nLINE\n')
data.close()



# второй вариант как открыть. после этого блока связь с файлом разрывается автоматически

with open('file.txt', 'w') as data: # означает "воспринимать оператор как переменную data"
    data.write('LINE = 1\n')
    data.write('LINE = 2\n')


# третий вариант наверно

path = 'file.txt'
data = open(path, 'r')
for line in data:
    print('{} line + data'.format(line))
data.close()

import file
file.f1()

# но можно указать "альяс" - это замена имени файла. указывается так:

import file as h
h.f2('!', 5) # вызов функции, умножающей строку на число. по умолчанию count = 3

# причем если в строку передать число, то оно умножится и вернется произведение. а если в функции поставить +,
# то складывать откажется:

h.f2(3,4)

# вызов функции, возвращающей факториал:

h.f3(5)

# вызов функции с кортежем:

h.f4('nums: ', 1,2,3,4,5)

# функция. прибавление суммы:

h.f5(5)



# кортежи
# a, b = 1, 2 - это просто множественное присваивание
a = (1, 2) # это уже кортеж
print(a) # обращение ко всему кортежу
print(a[1]) # обращение к отдельной координате кортежа
print(a[-2]) # по аналогии с обращением к элементу списка с конца
# координате кортежа нельзя присвоить новое значение. a[0] = 3 - ошибка

colors = ['red', 'green', 'blue']
print(colors) # ['red', 'green', 'blue'] это список. инициализируется в квадратных скобках
t = tuple(colors)
print(t) # ('red', 'green', 'blue') это кортеж. интциализируется в круглых скобках
# tuple() это функция, возвращающая кортеж

t = tuple(['red', 'green', 'blue']) # задание кортежа из списка

print(t[-2])

for e in t:
    print(e) # red green blue

# присвоить одну координату кортежу можно, поставив запятую:
tt = (1,)

# а это вообще непонятно что:
t = tuple(['red', 'green', 'blue'])
red, green, blue = t # это распаковка кортежа в переменные. так же можно распаковать и список



# еще одно хранилище данных — словари
# неупорядоченные коллекции произвольных объектов с доступом по ключу
#инициализируется словарь фигурными скобками {}, а обращение по ключу в квадратных []

dictionary = {} # объявление словаря

# задать значения для словаря.
# обратный слэш позволяет переносить строки. иначе надо в одну строку писать:
    
dictionary = \
{
    '1': 'number one',
    '2': 'number two',
    '3': 'number three'
}

print(dictionary) # распечатать словарь
print(dictionary['1']) # распечатать значение по ключу

# в цикле for переменная возвращает ключи

for k in dictionary.keys():
    print(k) # распечатать ключи
for v in dictionary.values():
    print(v) # распечатать значения
for i in dictionary:
    print(i) # это ключи
for i in dictionary:
    print(dictionary[i]) # это значения по ключу
for i in dictionary:
    print(dictionary[i], '- ', i) # это значения по ключу и ключи

dictionary['1'] = 'first' # так задается значение ключа '1'

print(dictionary['1'])

del dictionary['1'] # удаление значения
print(dictionary)



# множества
# хранение данных. задается с фигурными скобками {}. а обращение как в списках - элемент берется в скобки ()
# множества имеют операции логики (пересечение, объединение, разность, симметрическая разность и тд)


colors = {'abc', 'def', 'ghi'}
colors.add('jkl') # добавление элемента
colors.remove('jkl') # удаление. если элемента нет, будет ошибка
print(colors)
colors.discard('jk') # такое удаление не вызывает ошибку
colors.clear() # очистить

b = colors.copy() # копирование множества
c = colors.union(b) # объединение в двух множеств в новой переменной

b = colors.intersection(b) # пересечение
b = colors.difference(b) # множество элементов colors не принадлежащие b

# и т д. учить надо.

c = frozenset(b) # замороженное неизменяемое множество


























